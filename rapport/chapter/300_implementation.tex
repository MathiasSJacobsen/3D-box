\chapter{Implementation}

In this chapterâ€¦

\section{Early implementation}

In the early stages of implementation the idea for the application was to learn how 
to use the constraint system library HotDrink in a web application. Thus the 
application in mind was a simple \gls{gui} for a box in 3D. Her we wanted to have few 
constraints and keep the complexity low. 

The box had three dimensions: \textit{depth}, \textit{width} and \textit{height}. From 
these three values we calculate the value for the \textit{volume} of the box. See 
\texttt{calculateVolume} method in listing~\ref{metricsConstraint}. 
\texttt{calculateHeight}, \texttt{calculateDepth}, \texttt{calculateWidth} methods 
calculate the values for \texttt{height}, \texttt{depth} and \texttt{width} individually, 
whenever the value of \texttt{volume} is updated. Then HotDrink chooses the value lowest on the 
priority list, which is the one that was updated last.

\begin{lstlisting}[caption={Example of the constraint calculating the values of the box},label=metricsConstraint, language=hotdrink]
var width=1, depth=1, height=1, volume;

constraint metrics {
    calculateVolume(width, depth, height -> volume) => width * depth * height;
    calculateHeight(volume, depth, width -> height) => volume / (depth * width);
    calculateDepth(volume, width, height -> depth) => volume / (width * height);
    calculateWidth(volume, depth, height -> width) => volume / (depth * height);
}
\end{lstlisting}

HotDrink previously been tested out with React. Thus we decided to test it on Svelte. 
From listings~\ref{HotDrinkBinding},~\ref{reactiveStatement},~\ref{onMountHotdrink} 
as seen in section~\ref{sec:hotdrink} we can see how to bind HotDrink to Svelte. This 
becomes discombobulating when more values are added. Thus when we add one variable in 
HotDrink we have to make the same corresponding variable in Svelte. Then we have to 
bind the HotDrink variable to update the Svelte variable when HotDrink enforces 
constraints (listing~\ref{onMountHotdrink}). Use the Svelte reactive statement to 
listen to changes in the Svelte variable (listing \ref{reactiveStatement}) and call 
the \texttt{setHDValue} (\ref{HotDrinkBinding}) on when it is updated.

\section{ThreeJS}
We decided that it would be good for the end user to see the box in 3D. Thus we 
decided on adding a 3D library to the application. We ended up using 
SveltThree~\cite{sveltthree} which is a component library for Svelte for using 
ThreeJS~\cite{threejs}. 

SveltThree works by adding \textit{Scene}s to an \textit{canvas} component. A scene 
could include a \textit{camera}, \textit{lights} and \textit{meshes}. Meshes are 
used to represent a object in the scene --- the box in our case --- and the camera 
where the view of the canvas is placed. The different types of light are there to 
make the object feel more natural, in the application we use two types of lights: 
\textit{ambient-} and \textit{directional-light}. The canvas also takes a 
\textit{WebGLRender} component which is used to add configurations to the renderer. 

\begin{lstlisting}[caption={Example of a SveltThree setup},label=sveltthreesetup, language=javascript]
<Canvas let:sti w={canvasWidth*.6} h={canvasHeight * .6} interactive>

    <Scene {sti} let:scene id="scene1" props={{ background: 0x00000 } } >
        
        <PerspectiveCamera {scene} id="cam1" pos={[0, 0, 0]} lookAt={[0, 0, 0]} />
        <AmbientLight {scene} intensity={1.25} />
        <DirectionalLight {scene} pos={[3, 3, 3]} />
        <Mesh
        {scene}
        geometry={cubeGeometry}
        material={cubeMaterial}
        mat={{ roughness: 0.5, metalness: 0.5, color: 0xFF8001, }}
        pos={[-1, 0, 0]}
        rot={[.3, .4, 0]}
        scale={[1, 1, 1]} 
        />

        <Mesh
            {scene}
            geometry={sphereGeometry}
            material={sphereMaterial}
            mat={{ roughness: 0.5, metalness: 0.5, color: 0xF6E05E, }}
            pos={[$widthS*(3/4)+ ($depthS/5), 0, 0]}
            rot={[.2, .2, 0]}
            scale={[1, 1, 1]} 
        />

    </Scene>

    <WebGLRenderer
    {sti}
    sceneId="scene1"
    camId="cam1"
    config={{ antialias: true, alpha: true }} 
    />

</Canvas>
\end{lstlisting}

\section{Posten}
The Norwegian post-service packages domesticity and internationally from Norway. 
A package can in many cases be seen as a box. We decided to make a web application 
that would give you the price for sending a package with Posten. To still keep the 
application simple we decided to only support packages sent domesticity. Posten 
measures the height, depth, width and weight of the package. Thus we had to add a new 
variable to the constraint system, see listing~\ref{hotdrinkprice}, and with it the logic for calculating the price. 
Posten uses the following pricing 
model~\cite{postenNorgespakken}\footnote{If any of the measures --- height, depth, width --- of the package is larger than the maximum allowed there is a special package fee of 149 kr.} 
for domestic packages:

\begin{lstlisting}[caption={HotDrink logic for determining the price},label=hotdrinkprice, language=hotdrink]
constraint price {
    m1(w, d, h, kg -> price) => {
        if (kg <= 5) {
            if (h <= 35 && w <= 25 && d <=12) {
                return 70;
            } else if (h <= 120 && w <= 60 && d <=60) {
                return 129;
            } else {
                let spesialgodstillegg = 149;
                return 129 + spesialgodstillegg;
            }
        } else if (kg <=10) {
            if (h <= 120 && w <= 60 && d <=60) {
                return 129;
            } else {
                let spesialgodstillegg = 149;
                return 129 + spesialgodstillegg;
            }
        } else if (kg <= 25) {
            if (h <= 120 && w <= 60 && d <=60) {
                return 229;
            } else {
                let spesialgodstillegg = 149;
                return 229 + spesialgodstillegg;
            }
        } else if (kg <= 35) {
            if (h <= 120 && w <= 60 && d <=60) {
                return 299;
            } else {
                let spesialgodstillegg = 149;
                return 299 + spesialgodstillegg;
            }
        }
    }
}
\end{lstlisting}

\begin{table}[h]
    \centering
    \caption{Pricing model for domestic packages from Posten}
    \label{pricingmodel}
    \begin{tabular}{|l|cl|}
    \hline
             & \multicolumn{1}{l|}{\textless 35 x 25 x 12 cm} & \textless 120 x 60 x 60 cm  \\ \hline
    0-5 kg   & \multicolumn{1}{c|}{70 kr}                     & \multicolumn{1}{c|}{129 kr} \\ \hline
    0-10 kg  & \multicolumn{2}{c|}{129 kr}                                                  \\ \hline
    10-25 kg & \multicolumn{2}{c|}{229 kr}                                                  \\ \hline
    25-35 kg & \multicolumn{2}{c|}{299 kr}                                                  \\ \hline
    \end{tabular}
\end{table}

\section{Current state of HotDrink}

As mentioned in section \ref{sec:hotdrink} HotDrink is a JavaScript-based library for
multiway dataflow constraint systems in \gls{gui}s. In the current sate of the library 
there is no easy documentation for the library. There are two ways writing HotDrink, 
the developer can either access the HotDrink \gls{api} seen in listing~\ref{hotdrinkapi} 
or the developer can use the HotDrink \gls{dsl} seen in listing~\ref{HotDrinkDSL}. Both 
with there own disadvantages.

Using the \gls{api} can easily lead to errors and is not recommended. On line 9 and 10 
of listing~\ref{hotdrinkapi} the developer have to specify the index of the 
input-variables and the output-variables. In the example there are only two variables 
--- \texttt{c} and \texttt{f} --- thus it is not complicated to keep track of the index 
for the variables. In lager systems, it is easy to get lost in all the variables and 
there indexes.

Using the \gls{dsl} is the most used way to write HotDrink code. This is also easier to 
understand and more compact then the \gls{api}, as seen in the listing~\ref{HotDrinkDSL} 
and \ref{hotdrinkapi} where both have the same \textit{celsius to fahrenheit} example. In 
this project we used the HotDrink \gls{dsl}. The use of the tagged template literals, as 
discussed in section~\ref{sec:hotdrink}, makes the programming process error-prone. 
Finding and fixing code errors becomes a significantly difficult process. In systems 
larger then the celsius to fahrenheit, it is easy to get lost in all the constraints, 
not knowing which variables are affected by other constraints. This may lead to a 
non-desirable behavior.
This together with the fact that the error messages from HotDrink when using 
the \gls{dsl} are not helpful to the developer. There are no way of differentiating 
between a missing semi-colon or a missing closing bracket. They are generic error 
stacks. 

\begin{lstlisting}[caption={Example of how to use the HotDrink \gls{api} to simulate the corranltion between fahrenheit and celsius},label=hotdrinkapi, language=JavaScript]
import { Component, Method, ConstraintSpec, MaskNone } from 'hotdrink';

// create a component and emplace some variables
export const Temp = new Component("Temp");
const c = Temp.emplaceVariable("c", 1337);
const f = Temp.emplaceVariable("f");

// create a constraint spec
const toFahrenheit = new Method(2, [0], [1], [MaskNone], (c) => (c * 9 / 5 + 32));
const toCelsius = new Method(2, [1], [0], [MaskNone], (f) => (f - 32) * 5 / 9);

const graderSpec = new ConstraintSpec([toFahrenheit, toCelsius]);

// emplace a constraint built from the constraint spec
const grader = Temp.emplaceConstraint("grader", graderSpec, [c, f]);
\end{lstlisting}

